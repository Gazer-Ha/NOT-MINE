local AnimatorModule = {}

local function Contains(Table, Check)
	for Index, Value in next, Table do
		if rawequal(Check, Index) or rawequal(Check, Value) then
			return true
		end
	end
	return false
end

local AnimDefaults = {
	["Neck"] = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["RootJoint"] = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Right Shoulder"] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Shoulder"] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Right Hip"] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Hip"] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Head"] = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Torso"] = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Right Arm"] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Arm"] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Right Leg"] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Leg"] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
}

local function Edit(Joint, Change)
	if Joint then
		Joint.C0 = Change
	end
end

function AnimatorModule:ResetJoints(Rig)
	local RigHumanoid = Rig:FindFirstChildOfClass("Humanoid")
	assert(RigHumanoid:IsA("Humanoid"), "Rig Humanoid Missing!")
	if not RigHumanoid.RigType == Enum.HumanoidRigType.R6 then
		return error("Rig Humanoid is not R6!")
	end
	local Joints = {
		["Torso"] = Rig.HumanoidRootPart:FindFirstChild("RootJoint") or Rig.HumanoidRootPart:FindFirstChild("Root Joint"),
		["Left Arm"] = Rig.Torso["Left Shoulder"],
		["Right Arm"] = Rig.Torso["Right Shoulder"],
		["Left Leg"] = Rig.Torso["Left Hip"],
		["Right Leg"] = Rig.Torso["Right Hip"],
		["Head"] = Rig.Torso["Neck"],
	}
	for Limb, Joint in next, Joints do
		Edit(Joint, AnimDefaults[Limb])
	end
end

function AnimatorModule:LoadAnimation(Rig, Sequence)
	local RigHumanoid = Rig:FindFirstChildOfClass("Humanoid")
	if RigHumanoid.RigType ~= Enum.HumanoidRigType.R6 then
		return error("Rig Humanoid is not R6!")
	end

	local Joints = {}
	local jointMap = {
		["Torso"] = "RootJoint",
		["Left Arm"] = "Left Shoulder",
		["Right Arm"] = "Right Shoulder",
		["Left Leg"] = "Left Hip",
		["Right Leg"] = "Right Hip",
		["Head"] = "Neck"
	}
	local torso = Rig:FindFirstChild("Torso")
	local root = Rig:FindFirstChild("HumanoidRootPart")
	if torso and root then
		for part, jointName in pairs(jointMap) do
			local joint = (part == "Torso") and (root:FindFirstChild("RootJoint") or root:FindFirstChild("Root Joint")) or torso:FindFirstChild(jointName)
			if joint then
				Joints[part] = joint
			end
		end
	end

	local rigNames = {}
	for _, obj in ipairs(Rig:GetDescendants()) do
		rigNames[obj.Name] = true
	end

	local validValueTypes = {
		IntValue = true,
		StringValue = true,
		Folder = true
	}
	for _, v in ipairs(Sequence:GetDescendants()) do
		local className = v.ClassName
		if validValueTypes[className] or (className == "Pose" and not rigNames[v.Name]) then
			v:Destroy()
		end
	end

	local Class = {}
	Class.Speed = 1
	Class.KeepLast = 0
	local Keyframes = Sequence:GetKeyframes()
	table.sort(Keyframes, function(a, b) return a.Time < b.Time end)
	Class.Length = Keyframes[#Keyframes].Time
	local function Yield(Seconds)
		task.wait(Seconds / Class.Speed)
	end

	Class.Stopped = true
	Class.IsPlaying = false
	Class.TimePosition = 0
	Class.Looped = Sequence.Loop
	local Completion = Instance.new("BindableEvent")
	local Reached = Instance.new("BindableEvent")
	Class.Completed = Completion.Event
	Class.KeyframeReached = Reached.Event

	function Class:Play(FadeIn, Speed)
		if Speed and Speed < 0 then
			Speed = math.abs(Speed)
		end
		Class.Speed = math.clamp(Speed or 180, 1, 180)
		Class.Stopped = false
		Class.IsPlaying = true
		task.spawn(function()
			if FadeIn then
				Class.TimePosition -= FadeIn
			end
			Class.Completed:Connect(function()
				if Class.Looped then
					Class.TimePosition = 0
				end
			end)
			local connection
			connection = game:GetService("RunService").Stepped:Connect(function(_, dt)
				if Class.IsPlaying and not Class.Stopped and RigHumanoid.Health > 0 then
					Class.TimePosition += math.min(dt * Class.Speed, 1)
				else
					connection:Disconnect()
				end
			end)
		end)
		task.spawn(function()
			if FadeIn then
				Yield(FadeIn)
			end

			local keyframeData = {}
			for _, kf in ipairs(Keyframes) do
				local poses = {}
				for _, pose in ipairs(kf:GetDescendants()) do
					if Joints[pose.Name] then
						table.insert(poses, {
							Joint = Joints[pose.Name],
							CFrame = AnimDefaults[pose.Name] * pose.CFrame,
							EasingStyle = pose.EasingStyle,
							EasingDirection = pose.EasingDirection
						})
					end
				end
				keyframeData[#keyframeData + 1] = {
					Keyframe = kf,
					Time = kf.Time,
					Poses = poses
				}
			end

			repeat
				for i, data in ipairs(keyframeData) do
					local prevTime = keyframeData[i - 1] and keyframeData[i - 1].Time or 0
					local nextTime = keyframeData[i + 1] and keyframeData[i + 1].Time or data.Time + 0.5
					if not Class.Stopped and RigHumanoid.Health > 0 then
						Yield(data.Time - prevTime)
						for _, p in ipairs(data.Poses) do
							Edit(p.Joint, p.CFrame)
						end
						if i == #keyframeData and Class.KeepLast > 0 then
							Yield(Class.KeepLast)
						end
						Reached:Fire(data.Keyframe.Name)
					else
						break
					end
				end
				Completion:Fire()
			until not Class.Looped or Class.Stopped or RigHumanoid.Health == 0
			Class.IsPlaying = false
		end)
	end

	function Class:Stop()
		Class.Stopped = true
	end

	function Class:AdjustSpeed(Speed)
		if Speed < 0 then
			Speed = math.abs(Speed)
		end
		Class.Speed = math.clamp(Speed or Class.Speed, 1, 180)
	end

	return Class
end

return AnimatorModule
