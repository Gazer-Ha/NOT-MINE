local AnimatorModule = {}

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Default joint C0 values
local AnimDefaults = {
	["Neck"] = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["RootJoint"] = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Right Shoulder"] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Shoulder"] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Right Hip"] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Hip"] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Head"] = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Torso"] = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Right Arm"] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Arm"] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Right Leg"] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Leg"] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
}

-- Tween helper
local function Edit(joint, change, duration, style, direction)
	if not joint then return end

	style = typeof(style) == "EnumItem" and style or Enum.EasingStyle.Cubic
	direction = typeof(direction) == "EnumItem" and direction or Enum.EasingDirection.Out
	duration = duration or 0.1

	local tween = TweenService:Create(joint, TweenInfo.new(duration, style, direction), { C0 = change })
	tween:Play()
	return tween
end

-- Reset R6 joints to T-pose
function AnimatorModule:ResetJoints(rig)
	local humanoid = rig:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.RigType ~= Enum.HumanoidRigType.R6 then return end

	local torso = rig:FindFirstChild("Torso")
	local root = rig:FindFirstChild("HumanoidRootPart")
	if not torso or not root then return end

	local joints = {
		["Torso"] = root:FindFirstChild("RootJoint") or root:FindFirstChild("Root Joint"),
		["Left Arm"] = torso:FindFirstChild("Left Shoulder"),
		["Right Arm"] = torso:FindFirstChild("Right Shoulder"),
		["Left Leg"] = torso:FindFirstChild("Left Hip"),
		["Right Leg"] = torso:FindFirstChild("Right Hip"),
		["Head"] = torso:FindFirstChild("Neck")
	}

	for part, joint in pairs(joints) do
		Edit(joint, AnimDefaults[part], 0.25)
	end
end

-- Load and play an animation from KeyframeSequence
function AnimatorModule:LoadAnimation(rig, sequence)
	local humanoid = rig:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.RigType ~= Enum.HumanoidRigType.R6 then return end

	local torso = rig:FindFirstChild("Torso")
	local root = rig:FindFirstChild("HumanoidRootPart")
	if not torso or not root then return end

	local jointMap = {
		["Torso"] = root:FindFirstChild("RootJoint") or root:FindFirstChild("Root Joint"),
		["Left Arm"] = torso:FindFirstChild("Left Shoulder"),
		["Right Arm"] = torso:FindFirstChild("Right Shoulder"),
		["Left Leg"] = torso:FindFirstChild("Left Hip"),
		["Right Leg"] = torso:FindFirstChild("Right Hip"),
		["Head"] = torso:FindFirstChild("Neck")
	}

	-- Clean invalid or useless objects
	local validNames = {}
	for _, obj in ipairs(rig:GetDescendants()) do
		validNames[obj.Name] = true
	end

	for _, obj in ipairs(sequence:GetDescendants()) do
		if obj:IsA("IntValue") or obj:IsA("StringValue") or obj:IsA("Folder") or (obj:IsA("Pose") and not validNames[obj.Name]) then
			obj:Destroy()
		end
	end

	local keyframes = sequence:GetKeyframes()
	table.sort(keyframes, function(a, b) return a.Time < b.Time end)

	local Class = {}
	Class.Speed = 1
	Class.TimePosition = 0
	Class.IsPlaying = false
	Class.Stopped = true
	Class.Looped = sequence.Loop
	Class.Length = keyframes[#keyframes].Time

	local Completion = Instance.new("BindableEvent")
	local Reached = Instance.new("BindableEvent")
	Class.Completed = Completion.Event
	Class.KeyframeReached = Reached.Event

	local connection

	function Class:Play(fadeIn, speed)
		self:Stop()
		self.Speed = math.clamp(math.abs(speed or 1), 0.01, 180)
		self.Stopped = false
		self.IsPlaying = true
		self.TimePosition = -(fadeIn or 0)

		local keyframeData = {}
		for _, kf in ipairs(keyframes) do
			local poses = {}
			for _, pose in ipairs(kf:GetDescendants()) do
				local joint = jointMap[pose.Name]
				if joint and AnimDefaults[pose.Name] then
					table.insert(poses, {
						Joint = joint,
						CFrame = AnimDefaults[pose.Name] * pose.CFrame
					})
				end
			end
			table.insert(keyframeData, {
				Time = kf.Time,
				Name = kf.Name,
				Poses = poses
			})
		end

		local index = 1
		local lastTime = os.clock()

		connection = RunService.RenderStepped:Connect(function()
			if self.Stopped or not self.IsPlaying or humanoid.Health <= 0 then
				if connection then connection:Disconnect() connection = nil end
				return
			end

			local now = os.clock()
			local delta = now - lastTime
			lastTime = now
			self.TimePosition += delta * self.Speed

			while keyframeData[index] and self.TimePosition >= keyframeData[index].Time do
				for _, pose in ipairs(keyframeData[index].Poses) do
					Edit(pose.Joint, pose.CFrame, 0.1)
				end
				Reached:Fire(keyframeData[index].Name)
				index += 1
			end

			if index > #keyframeData then
				if self.Looped then
					self.TimePosition = 0
					index = 1
				else
					self.Stopped = true
					self.IsPlaying = false
					Completion:Fire()
					if connection then connection:Disconnect() connection = nil end
				end
			end
		end)
	end

	function Class:Stop()
		self.Stopped = true
		self.IsPlaying = false
		self.TimePosition = 0
		if connection then connection:Disconnect() connection = nil end
	end

	function Class:AdjustSpeed(speed)
		self.Speed = math.clamp(math.abs(speed or self.Speed), 0.01, 180)
	end

	return Class
end

return AnimatorModule
