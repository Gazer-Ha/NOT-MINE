-- wzpd was here 
local AnimatorModule = {}
local RunService = game:GetService("RunService")

local function accurateWait(seconds)
    local start = tick()
    repeat
        RunService.PreSimulation:Wait()
    until tick() - start >= seconds
end

local function Contains(Table, Check)
    for Index, Value in next, Table do 
        if rawequal(Check, Index) or rawequal(Check, Value) then 
            return true
        end
    end
    return false
end

local AnimDefaults = {
    ["Neck"] = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
    ["RootJoint"] = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
    ["Right Shoulder"] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
    ["Left Shoulder"] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
    ["Right Hip"] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
    ["Left Hip"] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
    ["Head"] = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
    ["Torso"] = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
    ["Right Arm"] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
    ["Left Arm"] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
    ["Right Leg"] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
    ["Left Leg"] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
}

-- Function to apply easing (simplified - only linear for now)
local function ApplyEasing(alpha, style, direction)
    -- Currently only linear interpolation
    -- You can expand this with more easing functions
    return alpha
end

-- Interpolation function using math.lerp for CFrames
local function InterpolateCFrame(startCF, endCF, alpha, style, direction)
    local easedAlpha = ApplyEasing(alpha, style, direction)
    
    -- For CFrames, we can't use math.lerp directly, so we interpolate components
    local startPos = startCF.Position
    local endPos = endCF.Position
    
    local interpolatedPos = startPos:Lerp(endPos, easedAlpha)
    
    -- Spherical interpolation for rotation (slerp)
    local interpolatedRotation = startCF:Lerp(endCF, easedAlpha)
    
    return CFrame.new(interpolatedPos) * interpolatedRotation - interpolatedRotation.Position + interpolatedPos
end

function AnimatorModule:ResetJoints(Rig)
    local RigHumanoid = Rig:FindFirstChildOfClass("Humanoid")
    assert(RigHumanoid:IsA("Humanoid"), "Rig Humanoid Missing!")
    if not RigHumanoid.RigType == Enum.HumanoidRigType.R6 then
        return error("Rig Humanoid is not R6!")
    end
    
    local Joints = {
        ["Torso"] = Rig.HumanoidRootPart:FindFirstChild("RootJoint") or Rig.HumanoidRootPart:FindFirstChild("Root Joint"),
        ["Left Arm"] = Rig.Torso["Left Shoulder"],
        ["Right Arm"] = Rig.Torso["Right Shoulder"],
        ["Left Leg"] = Rig.Torso["Left Hip"],
        ["Right Leg"] = Rig.Torso["Right Hip"],
        ["Head"] = Rig.Torso["Neck"],
    }
    
    for Limb, Joint in next, Joints do
        if Joint then
            Joint.C0 = AnimDefaults[Limb]
        end
    end
end

function AnimatorModule:LoadAnimation(Rig, KeyframeSequence)
    local Sequence = KeyframeSequence
    local RigHumanoid = Rig:FindFirstChildOfClass("Humanoid")
    
    if RigHumanoid.RigType ~= Enum.HumanoidRigType.R6 then
        return error("Rig Humanoid is not R6!")
    end
    
    local Joints = {
        ["Torso"] = Rig.HumanoidRootPart:FindFirstChild("RootJoint") or RigHumanoidRootPart:FindFirstChild("Root Joint"),
        ["Left Arm"] = Rig.Torso["Left Shoulder"],
        ["Right Arm"] = Rig.Torso["Right Shoulder"],
        ["Left Leg"] = Rig.Torso["Left Hip"],
        ["Right Leg"] = Rig.Torso["Right Hip"],
        ["Head"] = Rig.Torso["Neck"],
    }
    
    local Class = {}
    Class.Speed = 1
    Class.KeepLast = 0
    
    local Keyframes = Sequence:GetKeyframes()
    table.sort(Keyframes, function(a, b) return a.Time < b.Time end)
    Class.Length = Keyframes[#Keyframes].Time
    
    -- Pre-process poses for each keyframe
    local KeyframeData = {}
    for _, keyframe in ipairs(Keyframes) do
        local poses = {}
        for _, pose in ipairs(keyframe:GetDescendants()) do
            if pose:IsA("Pose") and Joints[pose.Name] then
                poses[pose.Name] = {
                    CFrame = pose.CFrame,
                    Style = pose.EasingStyle,
                    Direction = pose.EasingDirection
                }
            end
        end
        KeyframeData[keyframe] = {
            Time = keyframe.Time,
            Poses = poses,
            Name = keyframe.Name
        }
    end
    
    Class.Stopped = true
    Class.IsPlaying = false
    Class.TimePosition = 0
    Class.Looped = Sequence.Loop
    
    local Completion = Instance.new("BindableEvent")
    local Reached = Instance.new("BindableEvent")
    Class.Completed = Completion.Event
    Class.KeyframeReached = Reached.Event
    
    -- Animation playback function with accurate timing
    local function PlayAnimationThread()
        while not Class.Stopped and RigHumanoid.Health > 0 do
            local animationStartTime = tick()
            local currentAnimationTime = 0
            
            repeat
                for i = 1, #Keyframes do
                    local currentKeyframe = Keyframes[i]
                    local nextKeyframe = Keyframes[i + 1]
                    
                    if Class.Stopped or RigHumanoid.Health <= 0 then
                        break
                    end
                    
                    -- Calculate wait time for this keyframe segment
                    local waitTime = 0
                    if nextKeyframe then
                        waitTime = (nextKeyframe.Time - currentKeyframe.Time) / Class.Speed
                    else
                        waitTime = Class.KeepLast / Class.Speed
                    end
                    
                    -- Fire keyframe reached event
                    Reached:Fire(currentKeyframe.Name)
                    
                    -- Get poses for this keyframe
                    local poses = KeyframeData[currentKeyframe].Poses
                    
                    -- If this is not the last keyframe, interpolate to next
                    if nextKeyframe then
                        local nextPoses = KeyframeData[nextKeyframe].Poses
                        local interpolationStartTime = tick()
                        
                        -- Start interpolation for all poses
                        while tick() - interpolationStartTime < waitTime and not Class.Stopped and RigHumanoid.Health > 0 do
                            local elapsed = tick() - interpolationStartTime
                            local alpha = math.min(elapsed / waitTime, 1)
                            
                            -- Update all joints
                            for jointName, joint in pairs(Joints) do
                                if poses[jointName] and nextPoses[jointName] then
                                    local interpolatedCF = InterpolateCFrame(
                                        poses[jointName].CFrame,
                                        nextPoses[jointName].CFrame,
                                        alpha,
                                        poses[jointName].Style or Enum.EasingStyle.Linear,
                                        poses[jointName].Direction or Enum.EasingDirection.In
                                    )
                                    joint.C0 = AnimDefaults[jointName] * interpolatedCF
                                elseif poses[jointName] then
                                    -- No corresponding pose in next keyframe, maintain current
                                    joint.C0 = AnimDefaults[jointName] * poses[jointName].CFrame
                                end
                            end
                            
                            accurateWait(0) -- Yield without waiting, just for frame synchronization
                        end
                        
                        -- Ensure we end at exact pose
                        if not Class.Stopped and RigHumanoid.Health > 0 then
                            for jointName, joint in pairs(Joints) do
                                if nextPoses[jointName] then
                                    joint.C0 = AnimDefaults[jointName] * nextPoses[jointName].CFrame
                                end
                            end
                        end
                    else
                        -- Last keyframe, apply poses and wait for KeepLast
                        for jointName, joint in pairs(Joints) do
                            if poses[jointName] then
                                joint.C0 = AnimDefaults[jointName] * poses[jointName].CFrame
                            end
                        end
                        
                        if waitTime > 0 then
                            accurateWait(waitTime)
                        end
                    end
                    
                    -- Update current animation time
                    currentAnimationTime = currentKeyframe.Time
                end
                
                -- Check if looped animation should continue
                if Class.Looped and not Class.Stopped and RigHumanoid.Health > 0 then
                    Completion:Fire()
                    -- Reset to start
                    for jointName, joint in pairs(Joints) do
                        local firstPoses = KeyframeData[Keyframes[1]].Poses
                        if firstPoses[jointName] then
                            joint.C0 = AnimDefaults[jointName] * firstPoses[jointName].CFrame
                        end
                    end
                else
                    break
                end
                
            until not Class.Looped or Class.Stopped or RigHumanoid.Health <= 0
            
            Class.IsPlaying = false
            if not Class.Looped or RigHumanoid.Health <= 0 then
                Completion:Fire()
                break
            end
        end
    end
    
    function Class:Play(FadeIn, Speed)
        if Speed and Speed < 0 then
            Speed = math.abs(Speed)
        end
        Class.Speed = math.clamp(Speed or 180, 1, 180)
        Class.Stopped = false
        Class.IsPlaying = true
        
        -- Handle fade in
        if FadeIn and FadeIn > 0 then
            local fadeStartTime = tick()
            local initialPoses = {}
            
            -- Store initial joint positions
            for jointName, joint in pairs(Joints) do
                initialPoses[jointName] = joint.C0
            end
            
            -- Fade in from initial poses to first keyframe poses
            local firstPoses = KeyframeData[Keyframes[1]].Poses
            while tick() - fadeStartTime < FadeIn and not Class.Stopped do
                local elapsed = tick() - fadeStartTime
                local alpha = math.min(elapsed / FadeIn, 1)
                
                for jointName, joint in pairs(Joints) do
                    if firstPoses[jointName] then
                        local targetCF = AnimDefaults[jointName] * firstPoses[jointName].CFrame
                        local currentCF = initialPoses[jointName] or AnimDefaults[jointName]
                        local interpolatedCF = InterpolateCFrame(
                            currentCF,
                            targetCF,
                            alpha,
                            Enum.EasingStyle.Linear,
                            Enum.EasingDirection.In
                        )
                        joint.C0 = interpolatedCF
                    end
                end
                
                accurateWait(0)
            end
            
            -- Ensure we end at exact first pose
            if not Class.Stopped then
                for jointName, joint in pairs(Joints) do
                    if firstPoses[jointName] then
                        joint.C0 = AnimDefaults[jointName] * firstPoses[jointName].CFrame
                    end
                end
            end
        end
        
        -- Start animation thread
        task.spawn(PlayAnimationThread)
    end
    
    function Class:Stop()
        Class.Stopped = true
        Class.IsPlaying = false
    end
    
    function Class:AdjustSpeed(Speed)
        if Speed < 0 then
            Speed = math.abs(Speed)
        end
        Class.Speed = math.clamp(Speed or Class.Speed, 1, 180)
    end
    
    return Class
end

return AnimatorModule
