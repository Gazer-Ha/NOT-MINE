local RunService = game:GetService("RunService")

local AnimatorModule = {}

local AnimDefaults = {
	["Neck"] = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["RootJoint"] = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Right Shoulder"] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0),
	["Left Shoulder"] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Right Hip"] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0),
	["Left Hip"] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Head"] = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Torso"] = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Right Arm"] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0),
	["Left Arm"] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Right Leg"] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0),
	["Left Leg"] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
}

local function Edit(Joint, Change)
	if Joint then Joint.C0 = Change end
end

function AnimatorModule:ResetJoints(Rig)
	local hum = Rig:FindFirstChildOfClass("Humanoid")
	if not hum or hum.RigType ~= Enum.HumanoidRigType.R6 then return end
	local joints = {
		["Torso"] = Rig.HumanoidRootPart:FindFirstChild("RootJoint") or Rig.HumanoidRootPart:FindFirstChild("Root Joint"),
		["Left Arm"] = Rig.Torso:FindFirstChild("Left Shoulder"),
		["Right Arm"] = Rig.Torso:FindFirstChild("Right Shoulder"),
		["Left Leg"] = Rig.Torso:FindFirstChild("Left Hip"),
		["Right Leg"] = Rig.Torso:FindFirstChild("Right Hip"),
		["Head"] = Rig.Torso:FindFirstChild("Neck"),
	}
	for limb, joint in pairs(joints) do
		Edit(joint, AnimDefaults[limb])
	end
end

function AnimatorModule:LoadAnimation(Rig, Sequence)
	local hum = Rig:FindFirstChildOfClass("Humanoid")
	if not hum or hum.RigType ~= Enum.HumanoidRigType.R6 then return end

	local jointMap = {
		["Torso"] = "RootJoint",
		["Left Arm"] = "Left Shoulder",
		["Right Arm"] = "Right Shoulder",
		["Left Leg"] = "Left Hip",
		["Right Leg"] = "Right Hip",
		["Head"] = "Neck"
	}
	local joints = {}
	local torso, root = Rig:FindFirstChild("Torso"), Rig:FindFirstChild("HumanoidRootPart")
	for part, jointName in pairs(jointMap) do
		local joint = (part == "Torso" and root or torso):FindFirstChild(jointName)
		if joint then joints[part] = joint end
	end

	for _, v in ipairs(Sequence:GetDescendants()) do
		if v:IsA("Folder") or v:IsA("IntValue") or v:IsA("StringValue") or (v:IsA("Pose") and not Rig:FindFirstChild(v.Name)) then
			v:Destroy()
		end
	end

	local Keyframes = Sequence:GetKeyframes()
	table.sort(Keyframes, function(a, b) return a.Time < b.Time end)
	local Duration = Keyframes[#Keyframes].Time
	local Class = {
		Speed = 1,
		Stopped = true,
		IsPlaying = false,
		TimePosition = 0,
		Looped = Sequence.Loop,
		KeepLast = 0,
		Completed = Instance.new("BindableEvent").Event,
		KeyframeReached = Instance.new("BindableEvent").Event
	}

	function Class:Play(FadeIn, Speed)
		Class.Speed = math.clamp(math.abs(Speed or 180), 1, 180)
		Class.Stopped = false
		Class.IsPlaying = true
		if FadeIn then Class.TimePosition = -FadeIn end

		local kfData = {}
		for _, kf in ipairs(Keyframes) do
			local poses = {}
			for _, pose in ipairs(kf:GetDescendants()) do
				if joints[pose.Name] then
					table.insert(poses, {
						Joint = joints[pose.Name],
						CFrame = AnimDefaults[pose.Name] * pose.CFrame
					})
				end
			end
			table.insert(kfData, {Time = kf.Time, Poses = poses, Name = kf.Name})
		end

		task.spawn(function()
			local index = 1
			while not Class.Stopped and hum.Health > 0 do
				local dt = RunService.RenderStepped:Wait()
				Class.TimePosition += dt * Class.Speed

				if Class.TimePosition > Duration then
					if Class.Looped then
						Class.TimePosition = 0
						index = 1
					else
						break
					end
				end

				while index < #kfData and Class.TimePosition >= kfData[index + 1].Time do
					index += 1
					Class.KeyframeReached:Fire(kfData[index].Name)
				end

				local current, nextKf = kfData[index], kfData[index + 1]
				if not current or not nextKf then break end

				local alpha = math.clamp((Class.TimePosition - current.Time) / (nextKf.Time - current.Time), 0, 1)
				for _, pose in ipairs(current.Poses) do
					for _, nextPose in ipairs(nextKf.Poses) do
						if nextPose.Joint == pose.Joint then
							Edit(pose.Joint, pose.CFrame:Lerp(nextPose.CFrame, alpha))
							break
						end
					end
				end
			end
			Class.IsPlaying = false
		end)
	end

	function Class:Stop()
		Class.Stopped = true
	end

	function Class:AdjustSpeed(Speed)
		Class.Speed = math.clamp(math.abs(Speed or Class.Speed), 1, 180)
	end

	return Class
end

return AnimatorModule
