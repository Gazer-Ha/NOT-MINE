local m = {}

local function c(t, v)
	for i, x in next, t do
		if rawequal(v, i) or rawequal(v, x) then
			return true
		end
	end
end

local d = {
	["Neck"] = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["RootJoint"] = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Right Shoulder"] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Shoulder"] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Right Hip"] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Hip"] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Head"] = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Torso"] = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	["Right Arm"] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Arm"] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	["Right Leg"] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	["Left Leg"] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
}

local function e(j, cf, t, s, dir)
	j.C0 = cf
end

local function g(r)
	local t = r:FindFirstChild("Torso")
	local h = r:FindFirstChild("HumanoidRootPart")
	return {
		["Torso"] = h:FindFirstChild("RootJoint") or h:FindFirstChild("Root Joint"),
		["Left Arm"] = t and t:FindFirstChild("Left Shoulder"),
		["Right Arm"] = t and t:FindFirstChild("Right Shoulder"),
		["Left Leg"] = t and t:FindFirstChild("Left Hip"),
		["Right Leg"] = t and t:FindFirstChild("Right Hip"),
		["Head"] = t and t:FindFirstChild("Neck"),
	}
end

function m:ResetJoints(r)
	local h = r:FindFirstChildOfClass("Humanoid")
	assert(h and h:IsA("Humanoid"), "No Humanoid")
	if h.RigType ~= Enum.HumanoidRigType.R6 then
		error("Not R6")
	end
	local j = g(r)
	for l, k in next, j do
		e(k, d[l], 0.01, Enum.EasingStyle.Linear, Enum.EasingDirection.In)
	end
end

function m:LoadAnimation(r, s)
	local h = r:FindFirstChildOfClass("Humanoid")
	if h.RigType ~= Enum.HumanoidRigType.R6 then
		error("Not R6")
	end
	local j = g(r)
	local c = {Speed = 1, KeepLast = 0}
	local kfs = s:GetKeyframes()
	table.sort(kfs, function(a, b) return a.Time < b.Time end)
	c.Length = kfs[#kfs].Time

	local poses = {}
	for _, k in ipairs(kfs) do
		local p = {}
		for _, x in ipairs(k:GetDescendants()) do
			if x:IsA("Pose") and j[x.Name] then
				table.insert(p, x)
			end
		end
		poses[k] = p
	end

	for _, x in ipairs(s:GetDescendants()) do
		if x:IsA("IntValue") or x:IsA("StringValue") or x:IsA("Folder") or (x:IsA("Pose") and not r:FindFirstChild(x.Name, true)) then
			x:Destroy()
		end
	end

	c.Stopped = true
	c.IsPlaying = false
	c.TimePosition = 0
	c.Looped = s.Loop
	local done = Instance.new("BindableEvent")
	local hit = Instance.new("BindableEvent")
	c.Completed = done.Event
	c.KeyframeReached = hit.Event

	function c:Play(f, spd)
		if spd and spd < 0 then spd = math.abs(spd) end
		c.Speed = math.clamp(spd or 180, 1, 180)
		c.Stopped = false
		c.IsPlaying = true
		if f then c.TimePosition -= f end

		local rs = game:GetService("RunService")
		local conn
		conn = rs.Heartbeat:Connect(function(dt)
			if c.IsPlaying and not c.Stopped and h.Health > 0 then
				c.TimePosition += math.min(dt * c.Speed, 1)
			else
				conn:Disconnect()
			end
		end)

		task.spawn(function()
			if f then task.wait(f / c.Speed) end
			repeat
				for i = 1, #kfs do
					local a, b, z = kfs[i - 1], kfs[i], kfs[i + 1]
					if c.Stopped or h.Health <= 0 then break end
					if not a then
						for _, p in ipairs(poses[b] or {}) do
							e(j[p.Name], d[p.Name] * p.CFrame, 0.01, p.EasingStyle, p.EasingDirection)
						end
					else
						task.wait((b.Time - a.Time) / c.Speed)
						for _, p in ipairs(poses[b] or {}) do
							local dur = z and (z.Time - b.Time) / c.Speed or 0.5
							e(j[p.Name], d[p.Name] * p.CFrame, dur, p.EasingStyle, p.EasingDirection)
						end
					end
					hit:Fire(b.Name)
					if i == #kfs and c.KeepLast > 0 then
						task.wait(c.KeepLast)
					end
				end
				done:Fire()
			until not c.Looped or c.Stopped or h.Health <= 0
			c.IsPlaying = false
		end)
	end

	function c:Stop()
		c.Stopped = true
	end

	function c:AdjustSpeed(s)
		if s < 0 then s = math.abs(s) end
		c.Speed = math.clamp(s or c.Speed, 1, 180)
	end

	return c
end

return m
