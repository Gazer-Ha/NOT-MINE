-- wzpd was here
local A = {}

local D = {
	Neck = CFrame.new(0, 1, 0),
	RootJoint = CFrame.new(),
	RightShoulder = CFrame.new(1, 0.5, 0),
	LeftShoulder = CFrame.new(-1, 0.5, 0),
	RightHip = CFrame.new(1, -1, 0),
	LeftHip = CFrame.new(-1, -1, 0),
}

local function E(j, c)
	if j then j.C0 = c end
end

function A:R(r)
	local h = r:FindFirstChildOfClass("Humanoid")
	assert(h and h.RigType == Enum.HumanoidRigType.R6, "Rig must be R6")
	local j = {
		RootJoint = r.HumanoidRootPart:FindFirstChild("RootJoint") or r.HumanoidRootPart:FindFirstChild("Root Joint"),
		Neck = r.Torso:FindFirstChild("Neck"),
		RightShoulder = r.Torso:FindFirstChild("Right Shoulder"),
		LeftShoulder = r.Torso:FindFirstChild("Left Shoulder"),
		RightHip = r.Torso:FindFirstChild("Right Hip"),
		LeftHip = r.Torso:FindFirstChild("Left Hip"),
	}
	for k, v in pairs(j) do
		E(v, D[k])
	end
end

function A:L(r, s)
	local h = r:FindFirstChildOfClass("Humanoid")
	assert(h and h.RigType == Enum.HumanoidRigType.R6, "Rig must be R6")

	local j = {
		RootJoint = r.HumanoidRootPart:FindFirstChild("RootJoint") or r.HumanoidRootPart:FindFirstChild("Root Joint"),
		Neck = r.Torso:FindFirstChild("Neck"),
		RightShoulder = r.Torso:FindFirstChild("Right Shoulder"),
		LeftShoulder = r.Torso:FindFirstChild("Left Shoulder"),
		RightHip = r.Torso:FindFirstChild("Right Hip"),
		LeftHip = r.Torso:FindFirstChild("Left Hip"),
	}

	local kf = s:GetKeyframes()
	table.sort(kf, function(a, b) return a.Time < b.Time end)

	local pd = {}
	for _, f in ipairs(kf) do
		local p = {}
		for _, d in ipairs(f:GetDescendants()) do
			if d:IsA("Pose") and j[d.Name] then
				p[d.Name] = d.CFrame
			end
		end
		pd[#pd + 1] = {t = f.Time, d = p, n = f.Name}
	end

	local C = {
		spd = 1,
		tp = 0,
		stp = true,
		play = false,
		lp = s.Loop,
		keep = 0,
		done = Instance.new("BindableEvent").Event,
		kfEvt = Instance.new("BindableEvent").Event,
	}

	local i = 1
	local rs = game:GetService("RunService")
	if C.conn then C.conn:Disconnect() end

	function C:Play(fade, sp)
		self.stp, self.play = false, true
		self.spd = math.clamp(sp or 1, 0.1, 180)
		self.tp = fade and -fade or 0
		i = 1
		if C.conn then C.conn:Disconnect() end

		C.conn = rs.Heartbeat:Connect(function(dt)
			if self.stp or not self.play or h.Health <= 0 then
				C.conn:Disconnect()
				C.conn = nil
				return
			end
			self.tp += dt * self.spd
			while i <= #pd and self.tp >= pd[i].t do
				for k, v in pairs(pd[i].d) do
					E(j[k], D[k] * v)
				end
				self.kfEvt:Fire(pd[i].n)
				i += 1
			end
			if i > #pd then
				if self.lp then
					self.tp = 0
					i = 1
				else
					self.stp, self.play = true, false
					self.done:Fire()
					C.conn:Disconnect()
					C.conn = nil
				end
			end
		end)
	end

	function C:Stop()
		self.stp, self.play = true, false
		if C.conn then C.conn:Disconnect() C.conn = nil end
	end

	function C:Speed(s)
		self.spd = math.clamp(math.abs(s or self.spd), 0.1, 180)
	end

	return C
end

return A
