-- wzpd was here
local A = {}

local D = {
	Neck = CFrame.new(0,1,0,-1,0,0,0,0,1,0,1,0),
	RootJoint = CFrame.new(0,0,0,-1,0,0,0,0,1,0,1,0),
	["Right Shoulder"] = CFrame.new(1,0.5,0,0,0,1,0,1,0,-1,0,0),
	["Left Shoulder"] = CFrame.new(-1,0.5,0,0,0,-1,0,1,0,1,0,0),
	["Right Hip"] = CFrame.new(1,-1,0,0,0,1,0,1,0,-1,0,0),
	["Left Hip"] = CFrame.new(-1,-1,0,0,0,-1,0,1,0,1,0,0),
	Head = CFrame.new(0,1,0,-1,0,0,0,0,1,0,1,0),
	Torso = CFrame.new(0,0,0,-1,0,0,0,0,1,0,1,0),
	["Right Arm"] = CFrame.new(1,0.5,0,0,0,1,0,1,0,-1,0,0),
	["Left Arm"] = CFrame.new(-1,0.5,0,0,0,-1,0,1,0,1,0,0),
	["Right Leg"] = CFrame.new(1,-1,0,0,0,1,0,1,0,-1,0,0),
	["Left Leg"] = CFrame.new(-1,-1,0,0,0,-1,0,1,0,1,0,0)
}

local function SetC0(j, cf)
	if j then j.C0 = cf end
end

function A:Reset(r)
	local h = r:FindFirstChildOfClass("Humanoid")
	assert(h and h.RigType == Enum.HumanoidRigType.R6, "Must be R6 rig")

	local j = {
		Torso = r.HumanoidRootPart:FindFirstChild("RootJoint") or r.HumanoidRootPart:FindFirstChild("Root Joint"),
		["Left Arm"] = r.Torso:FindFirstChild("Left Shoulder"),
		["Right Arm"] = r.Torso:FindFirstChild("Right Shoulder"),
		["Left Leg"] = r.Torso:FindFirstChild("Left Hip"),
		["Right Leg"] = r.Torso:FindFirstChild("Right Hip"),
		Head = r.Torso:FindFirstChild("Neck"),
	}

	for n,v in pairs(j) do SetC0(v, D[n]) end
end

function A:Load(r, seq)
	local h = r:FindFirstChildOfClass("Humanoid")
	assert(h and h.RigType == Enum.HumanoidRigType.R6, "Must be R6 rig")

	local j = {
		Torso = r.HumanoidRootPart:FindFirstChild("RootJoint") or r.HumanoidRootPart:FindFirstChild("Root Joint"),
		["Left Arm"] = r.Torso:FindFirstChild("Left Shoulder"),
		["Right Arm"] = r.Torso:FindFirstChild("Right Shoulder"),
		["Left Leg"] = r.Torso:FindFirstChild("Left Hip"),
		["Right Leg"] = r.Torso:FindFirstChild("Right Hip"),
		Head = r.Torso:FindFirstChild("Neck"),
	}

	for _,v in ipairs(seq:GetDescendants()) do
		if v:IsA("IntValue") or v:IsA("StringValue") or v:IsA("Folder") then
			v:Destroy()
		elseif v:IsA("Pose") and not r:FindFirstChild(v.Name, true) then
			v:Destroy()
		end
	end

	local kfs = seq:GetKeyframes()
	table.sort(kfs, function(a,b) return a.Time < b.Time end)

	-- Cache pose data
	local poseCache = {}
	for _, kf in ipairs(kfs) do
		local poses = {}
		for _, p in ipairs(kf:GetDescendants()) do
			if p:IsA("Pose") and j[p.Name] then
				poses[p.Name] = p.CFrame
			end
		end
		table.insert(poseCache, {Time = kf.Time, Name = kf.Name, Data = poses})
	end

	local c = {
		Speed = 1,
		KeepLast = 0,
		Stopped = true,
		IsPlaying = false,
		TimePosition = 0,
		Looped = seq.Loop,
		Completed = Instance.new("BindableEvent").Event,
		KeyframeReached = Instance.new("BindableEvent").Event,
	}

	function c:Play(fade, speed)
		self.Speed = math.clamp(speed or 1, 0.1, 180)
		self.Stopped, self.IsPlaying = false, true
		self.TimePosition = fade and -fade or 0

		task.spawn(function()
			if fade then task.wait(fade / self.Speed) end

			repeat
				for i = 1, #poseCache do
					if self.Stopped or h.Health <= 0 then break end

					local k0 = poseCache[i - 1]
					local k1 = poseCache[i]
					local k2 = poseCache[i + 1]

					if k0 then
						task.wait((k1.Time - k0.Time) / self.Speed)
					end

					for name, cf in pairs(k1.Data) do
						local joint = j[name]
						if joint then
							SetC0(joint, D[name] * cf)
						end
					end

					c.KeyframeReached:Fire(k1.Name)

					if i == #poseCache and c.KeepLast > 0 then
						task.wait(c.KeepLast / self.Speed)
					end
				end

				c.Completed:Fire()
			until not c.Looped or c.Stopped or h.Health <= 0

			c.IsPlaying = false
		end)
	end

	function c:Stop()
		self.Stopped = true
		self.IsPlaying = false
	end

	function c:AdjustSpeed(s)
		self.Speed = math.clamp(math.abs(s or self.Speed), 0.1, 180)
	end

	return c
end

return A
